<!-- ---
title: nsq overview
date: 2018-08-03 10:58:35
category: language, go, nsq, doc
--- -->

nsq 概念

NSQ 是实时的分布式消息处理平台，属于去中心化的拓扑结构，具有无单点故障、高可用性以及能够保证消息可靠传递的特征。

## 1. 特性

- 支持无单点故障的分布式结构
- 水平扩展(没有中间件，无缝地添加更多的节点到集群)
- 低延迟消息传递
- 结合负载均衡和多播消息路由风格
- 主要在内存中完成工作(除了高水位线消息透明地保存在磁盘上)
- 提供运行时发现服务(nsqlookupd)帮助消费者找到生产者
- 依赖少，配置简单
- 集成内部状态统计

## 2. 预期保证

在一个分布式系统中，需要各方权衡才能达成最重要的目的，这里列举了NSQ 处理消息的行为策略，以明确NSQ 的期望边界，为你做出权衡提供依据。

### 2.1 消息不持久化

虽然系统支持消息持久化存储在磁盘中（通过 --mem-queue-size ），不过默认情况下消息都在内存中。

### 2.2 消息多次投递

消息最少投递一次，因为各种原因，消息可以被投递多次（客户端超时，连接失效，重新排队），由客户端负责实现幂等操作。

### 2.3 接收到的消息是无序的

不要依赖于投递给消费者的消息的顺序，消息可能来自重入队列(requeues)，内存和磁盘，所以消息是无序的。

### 2.4 消费者发现生产证

发现服务(nsqlookupd) 被设计为最终数据一致，nsqlookupd 节点不相互通信，所以只能保证消费者最终能发现生产者。


## 3. 性能

### 3.1 分布式性能

3 个nsqd 实例

消息体 100 个字节，并且通过 3 个话题（topic）发布，每个都包含一个 通道（channel），每个 通道（channel） 24 个客户端

生产者吞吐量 ~842k msgs/s, 使用了 80mb/s 的带宽 

消费者吞吐量 ~806k msgs/s, 使用了 76mb/s 的带宽 


### 3.2 单个节点性能

NSQ 设计的初衷是分布式，单个节点的性能虽然非常重要，但并不是目标。

• MacBook Air i7 2ghz
• go1.2
• NSQ v0.2.24
• 200 byte messages

GOMAXPROCS=1 (单个生产者，单个消费者)

```sh
$ ./bench.sh
results...
PUB: 2014/01/12 22:09:08 duration: 2.311925588s - 82.500mb/s - 432539.873ops/s - 2.312us/op
SUB: 2014/01/12 22:09:19 duration: 6.009749983s - 31.738mb/s - 166396.273ops/s - 6.010us/op
```

生产者吞吐量 ~432k msgs/s, 使用了 82mb/s 的带宽 

消费者吞吐量 ~166k msgs/s, 使用了 31mb/s 的带宽 


## 4. 部署问题

### 4.1 推荐的nsqd 部署结构

推荐将 nsqd 和生产消息的服务部署在一起运行。nsqd 是一个相对轻量的进程，它能很好和其他进程协同运行。这个模式使得消息流成为一个消费问题，而不是一个生产问题。

### 4.2 nsqlookupd 不用于生产端

NSQ 提供了消费端的发现服务，通过告诉消费者topic 的生产位置，减少了消费端的配置。

但是，这种方案不能用来解决发布端将内容发布给谁的问题。这是鸡生蛋，蛋生鸡的问题，在发布消息前，谁也不知道内容存在哪儿。


## 参考资料

- [quick_start](https://nsq.io/overview/features_and_guarantees.html)
- [performance](https://nsq.io/overview/performance.html)
- [FAQ](https://nsq.io/overview/faq.html)