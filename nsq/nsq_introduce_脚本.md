<!-- ---
title: nsq 简介
date: 2018-09-17 21:08:58
category: language, go, nsq
--- -->

nsq 简介，模块结构和消息投递模型

介绍NSQ 各个模块的功能和组合关系，以及NSQ 的消息模型，了解NSQ 中消息的多路转发概念。

## 1. nsq 模块

nsq 分为服务端和客户端，服务端有nsqd 守护进程和lookupd 守护进程，客户端有发布端和消费端。

[nsq 模块图]

### nsqd

nsqd 是一个守护进程，负责接收，排队，投递消息给客户端，它可以独立运行，不过通常是以集群部署。nsqd 监听2 个TCP 端口，一个给客户端，另一个是HTTP API。

### nsqlookupd

nsqlookupd 是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且nsqd 会广播话题（topic）和通（channel）信息。

nsqlookupd 有两个接口：TCP 接口提供给nsqd 使用。HTTP 接口，提供给客户端来发现nsqd。


NSQ 还包括一个辅助应用程序， nsqlookupd ，它提供了一个发现服务，消费者可以查找到提供他们感兴趣订阅话题的 nsqd 地址 。在配置方面，把消费者与生产者解耦开（它们都分别只需要知道哪里去连接 nsqlookupd 的共同实例，而不是对方），降低复杂性和维护。

在更底的层面，每个 nsqd 有一个与 nsqlookupd 的长期 TCP 连接，定期推动其状态。这个数据被 nsqlookupd 用于给消费者通知 nsqd 地址。对于消费者来说，一个暴露的 HTTP /lookup 接口用于轮询。

为话题引入一个新的消费者，只需启动一个配置了 nsqlookup 实例地址的 NSQ 客户端。无需为添加任何新的消费者或生产者更改配置，大大降低了开销和复杂性。

### 客户端

发布者和消费者

to_nsq 消息生产者实现

nsq_tail 消息消费者实现

## 2. 消息模型

单个 nsqd 实例被设计成可以同时处理多个数据流。流被称为“话题”和话题有 1 个或多个“通道”。每个通道都接收到一个话题中所有消息的拷贝。在实践中，一个通道映射到下行服务消费一个话题.

话题和通道都没有预先配置。话题由第一次发布消息到命名的话题或第一次通过订阅一个命名话题来创建。通道被第一次订阅到指定的通道创建。

话题 和通道的所有缓冲的数据相互独立，防止缓慢消费者造成对其他通道的积压（同样适用于话题级别）。一个通道一般会有多个客户端连接。假设所有已连接的客户端处于准备接收消息的状态，每个消息将被传递到一个随机的客户端

总结来说，话题有 1 个或多个“通道”。每个通道都接收到一个话题中所有消息的拷贝。消息从话题->通道是多路传送的（每个通道接收的所有该话题消息的副本)

nsqd 客户端（通过 TCP ）连接到指定话题的所有生产者实例；nsqlookupd ，高可用性是通过运行多个实例来实现。他们不直接相互通信和数据被认为是最终一


### 消息投递步骤

nsq 保证一个消息至少投递一次。工作原理如下（假设客户端成功连接并订阅一个话题）：

1. 客户表示他们已经准备好接收消息
2. NSQ 发送一条消息，并暂时将数据存储在本地（在 re-queue 或 timeout）
3. 客户端回复 FIN（结束）或 REQ（重新排队）分别指示成功或失败。如果客户端没有回复, NSQ 会在设定的时间超时，自动重新排队消息

## 参考资料

- [参考资料](#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)